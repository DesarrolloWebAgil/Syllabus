# Syllabus
Desarrollo Web Syllabus

## Overview

## Pre-Requisitos

## Herramientas
### Frameworks
Los siguientes son los Frameworks que se han usado en el curso.
* CodeIgniter
* YiiFramework
* DJango
* NodeJS

### Gestion de Proyectos
Algunas Herramientas que harán nuestra vida más sencilla para la coordinación del proyecto.
* Asana
* Basecamp
* Freedcamp
* Producteev
* Ganttproject ( OpenSource )


## Clase 1 - Frameworks


## Clase 2 - Equipos y MVC

###  ¿ Cuando necesitamos desarrollar software ?
* Ventajas de software open source
* Ventajas de contratar un servicio
* Ventajas del desarrollo propio.

### Ok, decidimos desarrollar una aplicación. ¿ Necesitamos un equipo ?

 * ¿ Cuando necesitamos trabajar en equipos ?
 * ¿ Beneficios de Trabajar en equipo ?
 * ¿ Hemos de verdad trabajado en equipos anteriormente?

### Divide & Conquer
* La mejor forma de atacar un problema complejo es dividiendolo en problemas sencillos.
	- La separación puede ser Vertical o Horizontal

Una forma lógica de dividir los aspectos de un problema es hacerlo de la siguiente manera :
* Mostrar la información al usuario
* Obtener la información
* Conectar a la BdD
* Obtener información relevante de la BdD
*	 Realizar procesos*
*	 Mostrar el resultado

Lo anterior un programador más experto podría separarlo usando un modelo MVC. Ojo, los modelos o patrones son soluciones probadas a problemas conocidos.

Integración Continua. Podríamos resumirlo como en vez de que cada uno de los equipos o desarrolladores tuviera solo una parte del código todos tuvieran la mayor posible para poder integrar todos desde el comienzo y rehusar lo más posible.


## Clase 3 - Como dar feedback

Antes de continuar con la parte más dura del desarrollo hay que hacer una pausa y ver un poco mejor como trabajar con las personas de mi equipo. En muchas ocasiones nos veremos en la necesidad de dar feedback, pero antes de continuar definamos bien que entendemos por feedback.

El feedback es esa acción que realizamos cuando reconocemos algo en otro, sea de su comportamiento, de sus capacidades o de su identidad. Es una manera de “reconocer” a la otra persona pero no sólo como algo implícito que se da por hecho, sino diciéndolo explícitamente.

En este caso en particular asumiremos que el feedback describe una situación pasada cuyo resultado puede influenciar en la misma situación o una similar en el presente o en el futuro.

> Happy are those who hear what other
people "have against them" and can improve.

>   William Shakespeare

Tipos de feedback
* Positivo
* Constructivo

### ¿ Como dar feedback ?

Antes de dar el feedback.

1. Piensa sobre la situación.
2. Describele la situación a la otra persona como tu la ves.
3. Pregunta como la otra persona ve la situación.
4. Alcancen un "mutuo" acuerdo sobre la situación.
5. Resuelvan la situación generando un plan.
6. ¡ Sigue el plan !.

#### ¿ Como dar feedback positivo ?
* Hazlo de inmediato.
* Hazlo público.
* Se específico.
* Dale la importancia que merece.
* Considera al receptor.
* Hazlo frecuentemente de ser necesario.
* Se sincer@.

#### ¿ Como dar feedback constructivo ?

* Ten tus emociones bajo control.
* Encuentra un lugar privado.
* Enfocate en las acciones no en la persona.
* Se específico.
* Hazlo lo antes posible.


### ¿ Como recibir feedback ?

* Trata de no estar a la defensiva.
* Escucha con atención para entender.
* Trata de ser parcial al recibirlo.
* Resume lo que escuchaste.
* Pregunta sobre las dudas que tengas.
* Pide ejemplos concretos.
* Revisa con otras personas para corroborar.



## Clase 4 - Manejo de versiones & Equipo


### Manejo de Equipo

Un software de administración de proyectos debería;
 * Facilitar la planificación de proyectos
 * Manejar y controlar de presupuesto
 * Asignar recursos
 * Facilitar la colaboración
 * Facilitar la comunicación
 * Manejar la calidad y documentación

### Control de versiones

 > Se llama control de versiones a la gestión de los diversos cambios que se realizan sobre los elementos de algún producto o una configuración del mismo. Una versión, revisión o edición de un producto, es el estado en el que se encuentra el mismo en un momento dado de su desarrollo o modificación.

 >Wikipedia


#### Características

Un sistema de control de versiones debe proporcionar:

* Mecanismo de almacenamiento de los elementos que deba gestionar (ej. archivos de texto, imágenes, documentación...).
* Posibilidad de realizar cambios sobre los elementos almacenados (ej. modificaciones parciales, añadir, borrar, renombrar o mover elementos).
* Registro histórico de las acciones realizadas con cada elemento o conjunto de elementos (normalmente pudiendo volver o extraer un estado anterior del producto).

Aunque no es estrictamente necesario, suele ser muy útil la generación de informes con los cambios introducidos entre dos versiones, informes de estado, marcado con nombre identificativo de la versión de un conjunto de ficheros, etc.

De los más populares podemos encontrar Git y Subversion.

#### Git
Git  es un software de control de versiones  pensando en la eficiencia y la confiabilidad del mantenimiento de versiones de aplicaciones cuando éstas tienen un gran número de archivos de código fuente.

### Subversion

Subversion es un sistema de control de versiones libre y de código fuente abierto. Es decir, Subversion maneja ficheros y directorios a través del tiempo. Hay un árbol de ficheros en un repositorio central. El repositorio es como un servidor de ficheros ordinario, excepto porque recuerda todos los cambios hechos a sus ficheros y directorios. Ésto le permite recuperar versiones antiguas de sus datos, o examinar el historial de cambios de los mismos. En este aspecto, mucha gente piensa en los sistemas de versiones como en una especie de “máquina del tiempo ”.


## Clase 5 - Procesos y Productos (PT1)


Si queremos tener éxito con lo que hagamos, la forma como lo hagamos importa.

¿ Cual es la diferencia de los siguientes términos ? ( ¡ Solo por curiosidad !)
* Eficacia
* Eficiencia

Hoy veremos :
* La relación entre el proceso y el producto.
* Definiremos calidad en un software. ( ¡ A nuestra manera !)
* Expectativas y requerimientos.
* Manifiesto Ágil.
* Feedback del usuario.
* Ejemplo práctico.


En el desarrollo de software ( No importa si es ágil o no ) el proceso tiene un papel fundamental. Una de las razones es que como objetivo tiene asegurar que podemos predecir el tiempo y esfuerzo en realizar un desarrollo.

      Si a lo anterior agregamos "Buenas prácticas" en nuestros procesos,
      la posibilidad de terminar con un software de alta calidad es muy alta.

¿ Cómo definimos que un software sea de alta calidad ?
* Cumple la función con la que fue desarrollado.
* Cumple con los requerimientos y expectativas del cliente.

Entonces para asegurar la calidad de software debemos :
* Cumplir con las expectativas del usuario.
* Reducir el número de bugs.
* Asegurar que podemos "acomodar" cambios en los requerimientos.
* Asegurar calidad y usabilidad.

       ¿ Cual sería la diferencia entre expectativas del usuario y sus requerimientos ?

En este momento es bueno que tengamos en consideración los principios del desarrollo ágil :
* Pueden ver el ágil manifesto haciendo  [click aquí](http://www.agilemanifesto.org/iso/es/principles.html)

La mejor forma que tenemos para cumplir las expectativas del usuario es seguir el primer principio del desarrollo ágil.
> Nuestra mayor prioridad es satisfacer al cliente
mediante la entrega temprana y continua de software
con valor.

Y esto lo logramos con entregas continuas en intervalos cortos de tiempo para que el o los usuarios puedan dar feedback sobre la aplicación. ( Les dije que la clase sobre feedback nos serviría ).

El Feedback además de ayudarnos a cumplir las expectativas del cliente nos ayuda a encontrar bugs de una manera oportuna, por lo que el tiempo que ocupa el periodo de marcha blanca o de arreglar los problemas se ve drasticamente afectado.

     Colaborar con el usuario es importante para entender lo que de verdad necesita.

Existe la gran posibilidad de que si no se cumplen las expectativas del cliente, a pesar de q ue se cumplen los requerimientos, el cliente jamás quede satisfecho con el producto.

Ejemplo Práctico:
* Se necesita desarrollar una conexión para una pasarela de pagos para los productos de un sitio web. ¿ Cómo lo proceserían ?


En nuestra aplicación, ya que seguiremos el modelo MVC, la calidad puede ser afectada por no seguir los patrones de desarrollo MVC.

#### Proceso
> Un proceso es un conjunto de actividades mutuamente relacionadas o que al interactuar juntas en los elementos de entrada los convierten en resultados.


#### Producto
> Un producto es un conjunto de características y atributos tangibles (forma, tamaño, color...) e intangibles (marca, imagen de empresa, servicio...) que el comprador acepta, en principio, como algo que va a satisfacer sus necesidades.


## Clase 6 - Manos a la masa.

Ya sabemos teóricamente mucho sobre como desarrollar nuestra aplicación. Ahora comienza el proceso en donde corroboramos que lo estemos haciendo bien. Antes de comenzar que necesitamos :
* Solución del problema fragmentada. ( Divide & Conquer !)
* Calendarización de las actividades.
* Actividades ya asignadas por miembros.
* La parte básica del sistema ya en la nube.
* Sistema de repositorios funcionando.
* Ojala a los miembros del equipo.

## Clase 7 - Procesos PT2

Hoy veremos :

* Las consecuencias de ignorar el proceso.
* La razón del por qué los procesos deben de ser respetados.
* Como comenzar con procesos en donde no tenemos.
* Los procesos ayudan, no dificultan.

Cómo hemos conversado en clases anteriores si queremos que algo tenga un resultado exitoso la forma como lo hacemos importa. ( ¡ Recuerden las diferencias entre eficiencia y eficacia !).

Un ejemplo básico de lo anterior puede ser aprobar un curso. Para aprobar el curso de manera satisfactoria en general se necesita ir a las clases, hacer las tareas, leer material adicional desde internet si fuera necesario complementar y estudiar para la evaluación.

### Ignorando el proceso.

De al forma que estamos desarrollando, tomando el problema y dividiendolo en hitos pequeños que pueden ser simples líneas de código, es muy probable que perdamos el concepto de lo que estámos haciendo.

Cuando el proyecto no es muy complejo en general no se tienen ningún problema simplificando el desarrollo en hitos pequeños, sin embargo al tener un proyecto más complejo se puede caer en sobre simplificar los hitos haciendo que los miembros del equipo pierdan la noción final de lo que se desarrolla.

    Ojo, no me malentiendan.
    Si la tarea es sencilla no la hagan compleja.

Nunca debemos olvidar que hay otros miembros del equipo trabajando en el código, en otras "partes del todo", por lo que debemos mantener sincronía en el código y las partes. Tenemos que hacer un esfuerzo para mantener todas las partes individuales del puzzle encajen de buena manera.

    Todos los integrantes deberían
    conocer el objetivo o  resultado esperado
    del proyecto en todo momento.
    Es la única forma de mantener la sincronía.

Teniendo esto en consideración, **¿ no es más sencillo si encontramos un problema simplemente arreglarlo de manera directa en el código ?** A esto le llamaremos harcoding y si es más sencillo, pero debemos recordar que estaremos trabajando en equipos y que no siempre es trivial el conocimiento que se necesita para encontrar el código que se insertó de esta manera. El proceso por el cual arreglamos un pequeño problema puede traer muchas complicaciones a futuro. Recuerden que por buenas prácticas para el desarrollo, para arreglar el problema haremos un branch de nuestra versión de desarrollo en donde corregiremos el problema, la probaremos en desarrollo y si todo va bien la pasaremos a producción ( master ).

Para ayudarnos en este proceso GitHub tiene una herramienta para "issue tracking" en donde publicaremos los problemas a medida que vayan sucediendo, asignaremos la persona encargada y veremos el estado de la solución. Si bien existen muchas herramientas que dan este tipo de soluciones, les recomiendo que empiecen ahora a usarlas. En el caso de nuestros proyectos tendremos una pestaña llamada issues en la página en GitHub en donde podremos acceder a esta funcionalidad. ¡ Esto también funciona para el programa del curso !

> Recomendación: Chicos, si bien no lo evaluaremos ni abarcaremos esto en el curso, les recomiendo leer sobre las pruebas unitarias.

### El proceso debe de ser respetado.

Ya comentamos sobre los problemas que puede traer ignorar el proceso, ¿ Pero como podemos evitarlos ?.

Para evitar que los miembros del equipo pierdan el foco del proyecto, lo mejor es que estén involucrados en la toma de desiciones y en el desarrollo del sistema. **¡Si pueden estar involucrados en el proceso de división de tareas mucho mejor!**.

#### Etapas del proyecto que deben quedar claras.

* Entender los requerimientos.
  * Que es lo que quiere el usuario.
  * Como poder modelar exactamento lo que está en la mente del usuario.

* Del modelo al diseño
  * Cual debería ser el diseño adecuado. ( Desde la arquitectura del software, pasando por la interface y finalizando en el Hardware)

* Del diseño a la implementación.
  * Tomar el diseño y traspasarlo a algo funcional.

* Pruebas
  * Verificar que la implementación concuerda con lo esperado por el cliente.
  * Encontar las diferencias entre lo que el espera y lo que se implementó.

* Arreglar.
  * Si existe una diferencia arreglarla.

* Verificar.
  * Revisar que el sistema funciona de manera adecuada después de arreglar los problemas.
* Feedback
  * Entregar parcialmente el sistema y recolectar el feedback por parte del cliente.
  * Estar preparado para los cambios.
  * Si existieran cambios, se inicia nuevamente el proceso de recolección de requerimientos, obtención de información y se continua el ciclo del proceso nuevamente.

  Recuerden que de la manera como estamos desarrollando, siguiendo los principios del manifiesto ágil, siempre deberíamos estar iterando en el ciclo anterior.

#### Como comenzar con procesos en donde no tenemos
Si no hay ningún proceso definido en el desarrollo, puede parecer incluso imposible introducir procesos para poder generar un orden, sin embargo, esto no es muy difícil.

Lo primero sería convencerse de que es necesario. Para ello pueden revisar lo siguiente :
* Cantidad de bugs encontrados por periodo.
* Tiempo necesitado en correcciones.
* Revisar si el bug es consecuencia de otro bug o solución.

Con esto debería de ser evidente que se puede optimizar el desarrollo introduciondo procesos.

> Es inevitable tener bugs en un software. Lo que es posible es reducir la cantidad de ellos y el tiempo que demoramos en solucionarlos.

Es importante que todos participen en las revisiones, no importando si es del código, del diseño, etc.

**¿Cual creen que es el tipo de bug más común?**

#### Los procesos ayudan, no dificultan.

A esta altura ya deberían tener más que claro que los procesos ayudan en la organización y el desarrollo del proyecto, sin embargo no nos hemos amarrado con ningún modelo en particular. Si bien seguimos los principios del manifiesto para el desarrollo ágil, existen distintos modelos predefinidos para seguir.

> Lo más importante es encontrar uno que no solo se adecue a los tiempos y las necesidades del cliente, es encontrar uno que se adecue al equipo.

## Clase 8 - Requerimientos del Usuario


## Proyecto del curso

* Generar los equipos de máximo 3 personas y mínimo 3 personas :)
* Definir un proyecto que "merezca" ser desarrollado. ( Feedback por parte de la clase es requerido )
* Definir una carta Gantt para el proyecto.
* Inicializar y utilizar un repositorio para el proyecto.
* Elegir y utilizar una herramienta de gestión de proyectos.
